# LLMå®‰å…¨é˜²æŠ¤ç³»ç»ŸæŠ€æœ¯å®ç°ç»†èŠ‚

## ğŸ“‹ ç›®å½•
1. [æ ¸å¿ƒæŠ€æœ¯é€‰å‹](#æ ¸å¿ƒæŠ€æœ¯é€‰å‹)
2. [llm-guardé›†æˆè¯¦è§£](#llm-guardé›†æˆè¯¦è§£)
3. [æ•æ„Ÿè¯å¤„ç†æœºåˆ¶](#æ•æ„Ÿè¯å¤„ç†æœºåˆ¶)
4. [APIå®¢æˆ·ç«¯å®ç°](#apiå®¢æˆ·ç«¯å®ç°)
5. [æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯](#æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯)
6. [å®‰å…¨æœºåˆ¶å®ç°](#å®‰å…¨æœºåˆ¶å®ç°)

## ğŸ› ï¸ æ ¸å¿ƒæŠ€æœ¯é€‰å‹

### æŠ€æœ¯æ ˆåˆ†æ

#### 1. llm-guard - æ•æ„Ÿè¯æ£€æµ‹æ ¸å¿ƒ
**é€‰æ‹©ç†ç”±**:
- ä¸“ä¸šçš„LLMå®‰å…¨é˜²æŠ¤åº“
- é«˜æ€§èƒ½çš„å­—ç¬¦ä¸²åŒ¹é…ç®—æ³•
- ä¸°å¯Œçš„é…ç½®é€‰é¡¹
- æ´»è·ƒçš„å¼€æºç¤¾åŒº

**æ ¸å¿ƒç‰¹æ€§**:
```python
from llm_guard.input_scanners import BanSubstrings
from llm_guard.input_scanners.ban_substrings import MatchType

# æ”¯æŒä¸¤ç§åŒ¹é…æ¨¡å¼
MatchType.STR   # å­—ç¬¦ä¸²çº§åˆ«åŒ¹é…ï¼ˆæ›´ä¸¥æ ¼ï¼‰
MatchType.WORD  # å•è¯çº§åˆ«åŒ¹é…ï¼ˆè¾ƒå®½æ¾ï¼‰
```

#### 2. OpenAI SDK - APIå®¢æˆ·ç«¯åŸºç¡€
**é€‰æ‹©ç†ç”±**:
- é€šä¹‰åƒé—®APIå…¼å®¹OpenAIæ ¼å¼
- æˆç†Ÿçš„é”™è¯¯å¤„ç†æœºåˆ¶
- æ”¯æŒæµå¼å’Œéæµå¼å“åº”
- å®Œå–„çš„ç±»å‹æç¤º

**å®ç°ç¤ºä¾‹**:
```python
from openai import OpenAI

client = OpenAI(
    api_key="your_qwen_api_key",
    base_url="https://dashscope.aliyuncs.com/compatible-mode/v1"
)
```

#### 3. pandas - æ•°æ®å¤„ç†
**é€‰æ‹©ç†ç”±**:
- é«˜æ•ˆçš„Excelæ–‡ä»¶è¯»å–
- å¼ºå¤§çš„æ•°æ®æ¸…æ´—åŠŸèƒ½
- å†…å­˜ä¼˜åŒ–çš„æ•°æ®å¤„ç†

**ä½¿ç”¨åœºæ™¯**:
```python
import pandas as pd

# ä»Excelæå–æ•æ„Ÿè¯
df = pd.read_excel('ï¼ˆ4ï¼‰æ‹¦æˆªå…³é”®è¯åˆ—è¡¨.xlsx')
sensitive_words = df['å…³é”®è¯'].dropna().tolist()
```

## ğŸ” llm-guardé›†æˆè¯¦è§£

### BanSubstringsæ‰«æå™¨åŸç†

#### 1. åˆå§‹åŒ–è¿‡ç¨‹
```python
class SensitiveWordDetector:
    def __init__(self, sensitive_words_file, match_type, case_sensitive, redact):
        # åŠ è½½æ•æ„Ÿè¯åˆ—è¡¨
        self.sensitive_words = self._load_sensitive_words()
        
        # åˆ›å»ºBanSubstringsæ‰«æå™¨
        self.scanner = BanSubstrings(
            substrings=self.sensitive_words,      # æ•æ„Ÿè¯åˆ—è¡¨
            match_type=self.match_type,           # åŒ¹é…ç±»å‹
            case_sensitive=self.case_sensitive,   # å¤§å°å†™æ•æ„Ÿ
            redact=self.redact,                   # æ˜¯å¦æ›¿æ¢
            contains_all=self.contains_all        # æ˜¯å¦éœ€è¦åŒ…å«æ‰€æœ‰è¯
        )
```

#### 2. æ‰«æç®—æ³•å®ç°
```python
def scan(self, text: str) -> Tuple[str, bool, float]:
    """
    æ‰«ææ–‡æœ¬ä¸­çš„æ•æ„Ÿè¯
    
    Returns:
        Tuple[str, bool, float]: (å¤„ç†åæ–‡æœ¬, æ˜¯å¦å®‰å…¨, é£é™©è¯„åˆ†)
    """
    if not text:
        return text, True, 0.0
    
    try:
        # è°ƒç”¨llm-guardçš„æ ¸å¿ƒæ‰«æé€»è¾‘
        sanitized_text, is_valid, risk_score = self.scanner.scan(text)
        
        # è®°å½•æ£€æµ‹ç»“æœ
        if not is_valid:
            logger.warning(f"æ£€æµ‹åˆ°æ•æ„Ÿè¯ï¼Œé£é™©è¯„åˆ†: {risk_score}")
        
        return sanitized_text, is_valid, risk_score
        
    except Exception as e:
        logger.error(f"æ•æ„Ÿè¯æ‰«æå¤±è´¥: {e}")
        # å®‰å…¨ä¼˜å…ˆï¼šå¤±è´¥æ—¶è®¤ä¸ºä¸å®‰å…¨
        return text, False, 1.0
```

#### 3. åŒ¹é…ç±»å‹å¯¹æ¯”

**å­—ç¬¦ä¸²çº§åˆ«åŒ¹é… (MatchType.STR)**:
```python
# ç¤ºä¾‹æ–‡æœ¬: "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å†…å®¹"
# æ•æ„Ÿè¯: "æµ‹è¯•"
# ç»“æœ: åŒ¹é…æˆåŠŸ â†’ "è¿™æ˜¯ä¸€ä¸ª[REDACT]å†…å®¹"

# ä¼˜ç‚¹: æ£€æµ‹æ›´å…¨é¢ï¼Œä¸ä¼šé—æ¼
# ç¼ºç‚¹: å¯èƒ½äº§ç”Ÿè¯¯æŠ¥
```

**å•è¯çº§åˆ«åŒ¹é… (MatchType.WORD)**:
```python
# ç¤ºä¾‹æ–‡æœ¬: "è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•å†…å®¹"  
# æ•æ„Ÿè¯: "æµ‹è¯•"
# ç»“æœ: éœ€è¦å®Œæ•´å•è¯åŒ¹é…

# ä¼˜ç‚¹: å‡å°‘è¯¯æŠ¥
# ç¼ºç‚¹: å¯èƒ½é—æ¼æŸäº›æƒ…å†µ
```

### é£é™©è¯„åˆ†æœºåˆ¶

#### llm-guardå†…éƒ¨è¯„åˆ†é€»è¾‘
```python
def calculate_risk_score(matches, text_length):
    """
    é£é™©è¯„åˆ†è®¡ç®—
    """
    if not matches:
        return -1.0  # å®‰å…¨æ ‡è®°
    
    # åŸºäºåŒ¹é…æƒ…å†µè®¡ç®—é£é™©
    if len(matches) > 0:
        return 1.0   # é«˜é£é™©
    
    return 0.0       # ä¸­ç­‰é£é™©
```

## ğŸ“ æ•æ„Ÿè¯å¤„ç†æœºåˆ¶

### æ•æ„Ÿè¯åŠ è½½ä¼˜åŒ–

#### 1. æ–‡ä»¶è¯»å–ä¼˜åŒ–
```python
def _load_sensitive_words(self) -> List[str]:
    """
    ä¼˜åŒ–çš„æ•æ„Ÿè¯åŠ è½½
    """
    if not os.path.exists(self.sensitive_words_file):
        logger.error(f"æ•æ„Ÿè¯æ–‡ä»¶ä¸å­˜åœ¨: {self.sensitive_words_file}")
        return []
    
    try:
        # ä½¿ç”¨ç”Ÿæˆå™¨å‡å°‘å†…å­˜å ç”¨
        words = []
        with open(self.sensitive_words_file, 'r', encoding='utf-8') as f:
            for line in f:
                word = line.strip()
                if word and len(word) > 1:  # è¿‡æ»¤æ— æ•ˆè¯æ±‡
                    words.append(word)
        
        # å»é‡å’Œæ’åº
        words = sorted(list(set(words)))
        logger.info(f"æˆåŠŸåŠ è½½ {len(words)} ä¸ªæ•æ„Ÿè¯")
        return words
        
    except Exception as e:
        logger.error(f"åŠ è½½æ•æ„Ÿè¯æ–‡ä»¶å¤±è´¥: {e}")
        return []
```

#### 2. åŠ¨æ€æ•æ„Ÿè¯ç®¡ç†
```python
def add_sensitive_words(self, words: List[str]) -> None:
    """
    åŠ¨æ€æ·»åŠ æ•æ„Ÿè¯
    """
    # éªŒè¯è¾“å…¥
    valid_words = [word.strip() for word in words if word.strip()]
    
    # æ·»åŠ åˆ°ç°æœ‰åˆ—è¡¨
    self.sensitive_words.extend(valid_words)
    
    # é‡æ–°åˆå§‹åŒ–æ‰«æå™¨
    self.scanner = BanSubstrings(
        substrings=self.sensitive_words,
        match_type=self.match_type,
        case_sensitive=self.case_sensitive,
        redact=self.redact,
        contains_all=self.contains_all
    )
    
    logger.info(f"æ·»åŠ äº† {len(valid_words)} ä¸ªæ•æ„Ÿè¯ï¼Œå½“å‰æ€»æ•°: {len(self.sensitive_words)}")
```

## ğŸŒ APIå®¢æˆ·ç«¯å®ç°

### é€šä¹‰åƒé—®APIé€‚é…

#### 1. è¯·æ±‚æ ¼å¼é€‚é…
```python
class QwenAPIClient:
    def chat_completion(self, messages: List[Dict[str, str]], **kwargs) -> Dict[str, Any]:
        """
        é€‚é…é€šä¹‰åƒé—®APIæ ¼å¼
        """
        # æ„å»ºè¯·æ±‚å‚æ•°
        params = {
            "model": self.model,
            "messages": messages,
            "max_tokens": self.max_tokens,
            "temperature": self.temperature,
            **kwargs
        }
        
        logger.debug(f"å‘é€APIè¯·æ±‚: {params}")
        
        try:
            # è°ƒç”¨API
            response = self.client.chat.completions.create(**params)
            
            # è½¬æ¢å“åº”æ ¼å¼
            return self._format_response(response)
            
        except Exception as e:
            logger.error(f"APIè°ƒç”¨å¤±è´¥: {e}")
            raise
```

#### 2. é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
```python
def robust_api_call(self, messages, max_retries=3):
    """
    å¥å£®çš„APIè°ƒç”¨
    """
    for attempt in range(max_retries):
        try:
            return self.chat_completion(messages)
            
        except openai.RateLimitError as e:
            # é™æµé”™è¯¯ - ç­‰å¾…åé‡è¯•
            wait_time = 2 ** attempt  # æŒ‡æ•°é€€é¿
            logger.warning(f"APIé™æµï¼Œç­‰å¾… {wait_time} ç§’åé‡è¯•")
            time.sleep(wait_time)
            
        except openai.APIError as e:
            # APIé”™è¯¯ - è®°å½•å¹¶é‡è¯•
            logger.error(f"APIé”™è¯¯ (å°è¯• {attempt + 1}/{max_retries}): {e}")
            if attempt == max_retries - 1:
                raise
                
        except Exception as e:
            # å…¶ä»–é”™è¯¯ - ç›´æ¥æŠ›å‡º
            logger.error(f"æœªçŸ¥APIé”™è¯¯: {e}")
            raise
    
    raise Exception("APIè°ƒç”¨å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
```

## âš¡ æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

### 1. æ•æ„Ÿè¯æ£€æµ‹ä¼˜åŒ–
```python
class OptimizedDetector:
    def __init__(self):
        # é¢„ç¼–è¯‘æ­£åˆ™è¡¨è¾¾å¼
        self._compiled_patterns = {}
        
        # ç¼“å­˜æ£€æµ‹ç»“æœ
        self._cache = {}
        self._cache_size = 1000
    
    def scan_with_cache(self, text: str):
        """
        å¸¦ç¼“å­˜çš„æ‰«æ
        """
        # è®¡ç®—æ–‡æœ¬å“ˆå¸Œ
        text_hash = hash(text)
        
        # æ£€æŸ¥ç¼“å­˜
        if text_hash in self._cache:
            return self._cache[text_hash]
        
        # æ‰§è¡Œæ‰«æ
        result = self.scanner.scan(text)
        
        # æ›´æ–°ç¼“å­˜
        if len(self._cache) >= self._cache_size:
            # æ¸…ç†æœ€æ—§çš„ç¼“å­˜
            oldest_key = next(iter(self._cache))
            del self._cache[oldest_key]
        
        self._cache[text_hash] = result
        return result
```

### 2. æ‰¹é‡å¤„ç†ä¼˜åŒ–
```python
def batch_scan(self, texts: List[str]) -> List[Tuple[str, bool, float]]:
    """
    æ‰¹é‡æ‰«ææ–‡æœ¬
    """
    results = []
    
    # å¹¶è¡Œå¤„ç†
    with ThreadPoolExecutor(max_workers=4) as executor:
        futures = [executor.submit(self.scan, text) for text in texts]
        
        for future in as_completed(futures):
            try:
                result = future.result()
                results.append(result)
            except Exception as e:
                logger.error(f"æ‰¹é‡æ‰«æå¤±è´¥: {e}")
                results.append((text, False, 1.0))
    
    return results
```

## ğŸ”’ å®‰å…¨æœºåˆ¶å®ç°

### 1. è¾“å…¥éªŒè¯
```python
def validate_input(self, text: str) -> bool:
    """
    è¾“å…¥éªŒè¯
    """
    # é•¿åº¦æ£€æŸ¥
    if len(text) > 10000:
        logger.warning("è¾“å…¥æ–‡æœ¬è¿‡é•¿")
        return False
    
    # ç¼–ç æ£€æŸ¥
    try:
        text.encode('utf-8')
    except UnicodeEncodeError:
        logger.warning("è¾“å…¥åŒ…å«æ— æ•ˆå­—ç¬¦")
        return False
    
    # æ ¼å¼æ£€æŸ¥
    if not isinstance(text, str):
        logger.warning("è¾“å…¥ç±»å‹é”™è¯¯")
        return False
    
    return True
```

### 2. å®‰å…¨æ—¥å¿—
```python
class SecurityLogger:
    def __init__(self):
        self.security_logger = logging.getLogger('security')
        handler = logging.FileHandler('security.log')
        formatter = logging.Formatter(
            '%(asctime)s - SECURITY - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        self.security_logger.addHandler(handler)
    
    def log_security_event(self, event_type: str, details: dict):
        """
        è®°å½•å®‰å…¨äº‹ä»¶
        """
        log_entry = {
            'event_type': event_type,
            'timestamp': datetime.now().isoformat(),
            'details': details
        }
        
        self.security_logger.warning(json.dumps(log_entry, ensure_ascii=False))
```

---

é€šè¿‡è¿™äº›æŠ€æœ¯å®ç°ç»†èŠ‚ï¼Œæ‚¨å¯ä»¥æ·±å…¥äº†è§£ç³»ç»Ÿçš„æ ¸å¿ƒæŠ€æœ¯åŸç†å’Œä¼˜åŒ–ç­–ç•¥ã€‚è¿™ä¸ªç³»ç»Ÿé‡‡ç”¨äº†å¤šé¡¹å…ˆè¿›æŠ€æœ¯ï¼Œç¡®ä¿åœ¨æä¾›å¼ºå¤§åŠŸèƒ½çš„åŒæ—¶ä¿æŒé«˜æ€§èƒ½å’Œå®‰å…¨æ€§ã€‚
